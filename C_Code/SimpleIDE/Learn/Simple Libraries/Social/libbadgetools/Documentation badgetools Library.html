<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>badgetools library: badgetools.h File Reference</title>
<link href="html/tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="html/doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="html/ParallaxLogo.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">badgetools library
   &#160;<span id="projectnumber">v0.51.0</span>
   </div>
   <div id="projectbrief">Collection of convenience functions for the Parallax eBadge</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.2 -->
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">badgetools.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This library provides convenient functions for a variety of Parallax eBadge operations.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;simpletools.h&quot;</code><br/>
<code>#include &lt;stdint.h&gt;</code><br/>
</div>
<p><a href="html/badgetools_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="define-members"></a>
Macros</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">LEDs</div></td></tr>
<tr class="memitem:ad76d1750a6cdeebd506bfcd6752554d2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad76d1750a6cdeebd506bfcd6752554d2"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="html/badgetools_8h.html#ad76d1750a6cdeebd506bfcd6752554d2">ON</a>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:ad76d1750a6cdeebd506bfcd6752554d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">For turning blue LEDs on. Example: led(0, ON) would turn the LED by the P27 label on. <br/></td></tr>
<tr class="memitem:a29e413f6725b2ba32d165ffaa35b01e5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a29e413f6725b2ba32d165ffaa35b01e5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="html/badgetools_8h.html#a29e413f6725b2ba32d165ffaa35b01e5">OFF</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:a29e413f6725b2ba32d165ffaa35b01e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">For turning off blue or RGB LEDs. Examples: led(1, OFF), would turn the LED by the P26 label off. rgb(L, OFF) would turn off the left rgb LED, and rgbs(OFF, OFF) would turn off the left and right RGB LEDs. <br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">RGB LEDs</div></td></tr>
<tr class="memitem:aa73214aa5f2f94f63d90bb4e3d99fe53"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa73214aa5f2f94f63d90bb4e3d99fe53"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="html/badgetools_8h.html#aa73214aa5f2f94f63d90bb4e3d99fe53">L</a>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:aa73214aa5f2f94f63d90bb4e3d99fe53"><td class="mdescLeft">&#160;</td><td class="mdescRight">For selecting the left of the two RGB LEDs. Example: rgb(L, RED) would set the left RGB LED to the color red. <br/></td></tr>
<tr class="memitem:a5c71a5e59a53413cd6c270266d63b031"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5c71a5e59a53413cd6c270266d63b031"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="html/badgetools_8h.html#a5c71a5e59a53413cd6c270266d63b031">R</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:a5c71a5e59a53413cd6c270266d63b031"><td class="mdescLeft">&#160;</td><td class="mdescRight">For selecting the right of the two RGB LEDs. Example: rgb(R, GREEN) would set the right RGB LED to the color green. <br/></td></tr>
<tr class="memitem:a79d10e672abb49ad63eeaa8aaef57c38"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a79d10e672abb49ad63eeaa8aaef57c38"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="html/badgetools_8h.html#a79d10e672abb49ad63eeaa8aaef57c38">BLUE</a>&#160;&#160;&#160;(1)</td></tr>
<tr class="memdesc:a79d10e672abb49ad63eeaa8aaef57c38"><td class="mdescLeft">&#160;</td><td class="mdescRight">For setting an RGB LED's color to blue. Examples: rgb(L, BLUE) sets the left RGB LED blue. rgbs(BLUE, BLUE) would set both RGB LEDs blue. <br/></td></tr>
<tr class="memitem:acfbc006ea433ad708fdee3e82996e721"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acfbc006ea433ad708fdee3e82996e721"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="html/badgetools_8h.html#acfbc006ea433ad708fdee3e82996e721">GREEN</a>&#160;&#160;&#160;(2)</td></tr>
<tr class="memdesc:acfbc006ea433ad708fdee3e82996e721"><td class="mdescLeft">&#160;</td><td class="mdescRight">For setting an RGB LED's color to green. Examples: rgb(R, GREEN) sets the right RGB LED to green. rgbs(GREEN, GREEN) would set both RGB LEDs green. <br/></td></tr>
<tr class="memitem:ad243f93c16bc4c1d3e0a13b84421d760"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad243f93c16bc4c1d3e0a13b84421d760"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="html/badgetools_8h.html#ad243f93c16bc4c1d3e0a13b84421d760">CYAN</a>&#160;&#160;&#160;(3)</td></tr>
<tr class="memdesc:ad243f93c16bc4c1d3e0a13b84421d760"><td class="mdescLeft">&#160;</td><td class="mdescRight">For setting an RGB LED's color to cyan. Examples: rgb(L, CYAN) sets the left RGB LED to cyan. rgbs(CYAN, CYAN) would set both RGB LEDs cyan. <br/></td></tr>
<tr class="memitem:a8d23feea868a983c8c2b661e1e16972f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8d23feea868a983c8c2b661e1e16972f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="html/badgetools_8h.html#a8d23feea868a983c8c2b661e1e16972f">RED</a>&#160;&#160;&#160;(4)</td></tr>
<tr class="memdesc:a8d23feea868a983c8c2b661e1e16972f"><td class="mdescLeft">&#160;</td><td class="mdescRight">For setting an RGB LED's color to red. Examples: rgb(R, RED) sets the right RGB LED red. rgbs(CYAN, CYAN) would set both RGB LEDs red. <br/></td></tr>
<tr class="memitem:a6f699060902f800f12aaae150f3a708e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6f699060902f800f12aaae150f3a708e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="html/badgetools_8h.html#a6f699060902f800f12aaae150f3a708e">MAGENTA</a>&#160;&#160;&#160;(5)</td></tr>
<tr class="memdesc:a6f699060902f800f12aaae150f3a708e"><td class="mdescLeft">&#160;</td><td class="mdescRight">For setting an RGB LED's color to magenta. Examples: rgb(L, MAGENTA) sets the left RGB LED magenta. rgbs(MAGENTA, MAGENTA) would set both RGB LEDs magenta. <br/></td></tr>
<tr class="memitem:abf681265909adf3d3e8116c93c0ba179"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abf681265909adf3d3e8116c93c0ba179"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="html/badgetools_8h.html#abf681265909adf3d3e8116c93c0ba179">YELLOW</a>&#160;&#160;&#160;(6)</td></tr>
<tr class="memdesc:abf681265909adf3d3e8116c93c0ba179"><td class="mdescLeft">&#160;</td><td class="mdescRight">For setting an RGB LED's color to yellow. Examples: rgb(L, YELLOW) sets the left RGB LED yellow. rgbs(YELLOW, YELLOW) would set both RGB LEDs yellow. <br/></td></tr>
<tr class="memitem:a87b537f5fa5c109d3c05c13d6b18f382"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a87b537f5fa5c109d3c05c13d6b18f382"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="html/badgetools_8h.html#a87b537f5fa5c109d3c05c13d6b18f382">WHITE</a>&#160;&#160;&#160;(7)</td></tr>
<tr class="memdesc:a87b537f5fa5c109d3c05c13d6b18f382"><td class="mdescLeft">&#160;</td><td class="mdescRight">For setting an RGB LED's color to white. Examples: rgb(L, WHITE) sets the left RGB LED white. rgbs(WHITE, WHITE) would set both RGB LEDs white. <br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ad0292a56ddd0bc4e0cf114599e8eab64"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="html/badgetools_8h.html#ad0292a56ddd0bc4e0cf114599e8eab64">badge_setup</a> (void)</td></tr>
<tr class="memdesc:ad0292a56ddd0bc4e0cf114599e8eab64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set up all available badge drivers. Call this function at the start of any given program to allow access to ensure that the rest of this library's functions work properly.  <a href="#ad0292a56ddd0bc4e0cf114599e8eab64"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">LED Lights</div></td></tr>
<tr class="memitem:aab5acb9b826ee20df2bc52d0c9912806"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="html/badgetools_8h.html#aab5acb9b826ee20df2bc52d0c9912806">led</a> (int n, int state)</td></tr>
<tr class="memdesc:aab5acb9b826ee20df2bc52d0c9912806"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a blue LED (from 0 to 5) to a state (ON or OFF). Examples: led(1, ON) turns the blue LED next to the P26 label on. led(3, OFF) turns the blue LED by the P15 label off.  <a href="#aab5acb9b826ee20df2bc52d0c9912806"></a><br/></td></tr>
<tr class="memitem:a01e98884f4e84a900658123df508c2b3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="html/badgetools_8h.html#a01e98884f4e84a900658123df508c2b3">leds</a> (int bits)</td></tr>
<tr class="memdesc:a01e98884f4e84a900658123df508c2b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the on/off states of the 6 blue LEDs with a number that contains six binary 1/0 digits. How does the 6 digit binary number work? Count the number of digits from the right, and that's the led number used in the <a class="el" href="html/badgetools_8h.html#aab5acb9b826ee20df2bc52d0c9912806" title="Set a blue LED (from 0 to 5) to a state (ON or OFF). Examples: led(1, ON) turns the blue LED next to ...">led(int n, int state)</a> function. For example, leds(0b110010) is equivalent to these six led calls: led(5, ON); led(4, ON); led(3, OFF); led(2, OFF); led(1, ON); led(0, OFF).  <a href="#a01e98884f4e84a900658123df508c2b3"></a><br/></td></tr>
<tr class="memitem:aa6eef30729fc643575d5424d6b0826ca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="html/badgetools_8h.html#aa6eef30729fc643575d5424d6b0826ca">rgb</a> (int side, int color)</td></tr>
<tr class="memdesc:aa6eef30729fc643575d5424d6b0826ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the color of the left or right RGB LED. Examples: rgb(L, RED) makes the left RGB LED glow red. rgb(R, GREEN) makes the right one glow green. Color options include BLUE, GREEN, CYAN, YELLOW, RED, MAGENTA, WHITE. You can also use OFF to make a light that is glowing turn off. The numeric values of these are listed in Macros -&gt; RGB LEDs.  <a href="#aa6eef30729fc643575d5424d6b0826ca"></a><br/></td></tr>
<tr class="memitem:a88a29be892374a870d31faf42487629e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="html/badgetools_8h.html#a88a29be892374a870d31faf42487629e">rgbs</a> (int colorL, int colorR)</td></tr>
<tr class="memdesc:a88a29be892374a870d31faf42487629e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set both RGB LED colors with one function call. See rgb function for color options.  <a href="#a88a29be892374a870d31faf42487629e"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Touch Buttons</div></td></tr>
<tr class="memitem:a8907df5dd630732bf6f0232a41ac87c3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="html/badgetools_8h.html#a8907df5dd630732bf6f0232a41ac87c3">button</a> (int pad)</td></tr>
<tr class="memdesc:a8907df5dd630732bf6f0232a41ac87c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the state of a touch button (1) pressed, (0) not pressed. Numbering {6, 5, 4, 3, 2, 1, 0} maps the pads by {OSH, P17, P16, P15, P25, P26, P27}. Example: int state = button(3); If state stores 1, it means the pad next to the P15 label is pressed. If it instead stores 0, the button is not pressed.  <a href="#a8907df5dd630732bf6f0232a41ac87c3"></a><br/></td></tr>
<tr class="memitem:a8a9ade72d959d6ceb25fa2135800e755"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="html/badgetools_8h.html#a8a9ade72d959d6ceb25fa2135800e755">buttons</a> (void)</td></tr>
<tr class="memdesc:a8a9ade72d959d6ceb25fa2135800e755"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the states of all seven touch buttons, and returns them in a value with 1s and 0s that correspond to each touch button. Example: int states = <a class="el" href="html/badgetools_8h.html#a8a9ade72d959d6ceb25fa2135800e755" title="Gets the states of all seven touch buttons, and returns them in a value with 1s and 0s that correspon...">buttons()</a>; If states stores 0b1110010, it means: {OSH-pressed, P17-pressed, P16-pressed, P15-not pressed, P25-not pressed, P26-pressed, P27-not pressed}.  <a href="#a8a9ade72d959d6ceb25fa2135800e755"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Contact Storage</div></td></tr>
<tr class="memitem:a331da7055ac2effe981ac1701d1a6104"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="html/badgetools_8h.html#a331da7055ac2effe981ac1701d1a6104">store</a> (char *contact)</td></tr>
<tr class="memdesc:a331da7055ac2effe981ac1701d1a6104"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store a character string of up to 128 characters to EEPROM. Example: char s[] = "abcd"; store(s);.  <a href="#a331da7055ac2effe981ac1701d1a6104"></a><br/></td></tr>
<tr class="memitem:aae1272cb6eca63cbc542bac82619e374"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="html/badgetools_8h.html#aae1272cb6eca63cbc542bac82619e374">stored</a> (char *s)</td></tr>
<tr class="memdesc:aae1272cb6eca63cbc542bac82619e374"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a string has already been stored in EEPROM. Example: if(!stored("abcd")) store("abcd");.  <a href="#aae1272cb6eca63cbc542bac82619e374"></a><br/></td></tr>
<tr class="memitem:a65c00fbff5b198cfebecfdae18269cd2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="html/badgetools_8h.html#a65c00fbff5b198cfebecfdae18269cd2">retrieve</a> (char *contact, int recIdx)</td></tr>
<tr class="memdesc:a65c00fbff5b198cfebecfdae18269cd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy string with a certain index number from EEPROM to a character array.  <a href="#a65c00fbff5b198cfebecfdae18269cd2"></a><br/></td></tr>
<tr class="memitem:aa56c6ce64e97f04b4acde7f69b4aa54b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="html/badgetools_8h.html#aa56c6ce64e97f04b4acde7f69b4aa54b">eeprint</a> (const char *fmt,...)</td></tr>
<tr class="memdesc:aa56c6ce64e97f04b4acde7f69b4aa54b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use to store strings to EEPROM in a manner similar to displaying combinations of strings and variables in the SimpleIDE terminal with the print function. Examples: eeprint("Hello EEPROM"); float f = PI; int n = 4s; char s[] = "PI and answer to universe"; eeprint("%1.3f\n%03d\n
%30s\n", f, n, s); // Result to EEPROM: "Hello EEPROM"[0]"3.141"[10]"042" [10]"PI and answer to universe"[10][0]. This information can be conveniently retrieved back from EEPROM and placed in variables with the eescan function.  <a href="#aa56c6ce64e97f04b4acde7f69b4aa54b"></a><br/></td></tr>
<tr class="memitem:aa22d91d3a160d8b14b40db1864bed8d1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="html/badgetools_8h.html#aa22d91d3a160d8b14b40db1864bed8d1">eeprinted</a> (const char *fmt,...)</td></tr>
<tr class="memdesc:aa22d91d3a160d8b14b40db1864bed8d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Can be called before storing a record with eeprint. Example: if(!eeprinted("Hello EEPROM") eeprint("Hello EEPROM");.  <a href="#aa22d91d3a160d8b14b40db1864bed8d1"></a><br/></td></tr>
<tr class="memitem:af31cd89d7d934033828b58689e59530b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="html/badgetools_8h.html#af31cd89d7d934033828b58689e59530b">eescan</a> (int recIdx, const char *fmt,...)</td></tr>
<tr class="memdesc:af31cd89d7d934033828b58689e59530b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use to retrieve strings to EEPROM in a manner similar to retrieving strings that represent combinations of strings and variables from the SimpleIDE terminal with the scan function. Examples: This example will retrieve the what the eeprint examples stored in EEPROM: char s1[14]; eescan(1, "%s", s1); float f; int n; char s2[30]; eescan("%f%d%s", f, n, s2); // Result: s1 = "Hello EEPROM", f = 3.141, n = 42, s2 = "PI and 
answer to universe".  <a href="#af31cd89d7d934033828b58689e59530b"></a><br/></td></tr>
<tr class="memitem:a0418dc4511db1c97abdda0aa224c829f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="html/badgetools_8h.html#a0418dc4511db1c97abdda0aa224c829f">contacts_count</a> ()</td></tr>
<tr class="memdesc:a0418dc4511db1c97abdda0aa224c829f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find out how many contacts are currently stored in EEPROM. This is useful for setting up a loop to fetch all contacts.  <a href="#a0418dc4511db1c97abdda0aa224c829f"></a><br/></td></tr>
<tr class="memitem:a5dfdae3cf6bfe06eff13eb3f09cb1997"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5dfdae3cf6bfe06eff13eb3f09cb1997"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="html/badgetools_8h.html#a5dfdae3cf6bfe06eff13eb3f09cb1997">contacts_eraseAll</a> ()</td></tr>
<tr class="memdesc:a5dfdae3cf6bfe06eff13eb3f09cb1997"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases user portion of EEPROM by placing 255 in each cell. This erasure affects addresses 32768 through 65535. <br/></td></tr>
<tr class="memitem:a62e72310fc01704d6d71f73f9235a63f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a62e72310fc01704d6d71f73f9235a63f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="html/badgetools_8h.html#a62e72310fc01704d6d71f73f9235a63f">contacts_displayAll</a> ()</td></tr>
<tr class="memdesc:a62e72310fc01704d6d71f73f9235a63f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Display all contacts in SimpleIDE Terminal. <br/></td></tr>
<tr class="memitem:ae0c1e9fbf92b55e20438d8e21c3d3c28"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="html/badgetools_8h.html#ae0c1e9fbf92b55e20438d8e21c3d3c28">contacts_setStartAddr</a> (int address)</td></tr>
<tr class="memdesc:ae0c1e9fbf92b55e20438d8e21c3d3c28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the start address of the contacts. This can be used to reserve some user EEPROM space for other purposes before the start of the contacts.  <a href="#ae0c1e9fbf92b55e20438d8e21c3d3c28"></a><br/></td></tr>
<tr class="memitem:a1ba3896aea3feb5a6ae8c7fa70092054"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="html/badgetools_8h.html#a1ba3896aea3feb5a6ae8c7fa70092054">ee_writeByte</a> (unsigned char value, int addr)</td></tr>
<tr class="memdesc:a1ba3896aea3feb5a6ae8c7fa70092054"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store a byte value at a certain address in the Propeller Chip's dedicated EEPROM.  <a href="#a1ba3896aea3feb5a6ae8c7fa70092054"></a><br/></td></tr>
<tr class="memitem:aaea98e6d42cb2de7d6f3c050a18a27fc"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="html/badgetools_8h.html#aaea98e6d42cb2de7d6f3c050a18a27fc">ee_readByte</a> (int addr)</td></tr>
<tr class="memdesc:aaea98e6d42cb2de7d6f3c050a18a27fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a byte value from a certain address in the Propeller Chip's dedicated EEPROM.  <a href="#aaea98e6d42cb2de7d6f3c050a18a27fc"></a><br/></td></tr>
<tr class="memitem:a9858528bce4acd6ced284e4c84de9e0b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="html/badgetools_8h.html#a9858528bce4acd6ced284e4c84de9e0b">ee_writeShort</a> (short value, int addr)</td></tr>
<tr class="memdesc:a9858528bce4acd6ced284e4c84de9e0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store a short value at a certain address in the Propeller Chip's dedicated EEPROM. A short value occupies two bytes, so the next value should be stored at an address value that's two bytes higher.  <a href="#a9858528bce4acd6ced284e4c84de9e0b"></a><br/></td></tr>
<tr class="memitem:a9d180d67243bc16af61e15bf8f3edaf4"><td class="memItemLeft" align="right" valign="top">short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="html/badgetools_8h.html#a9d180d67243bc16af61e15bf8f3edaf4">ee_readShort</a> (int addr)</td></tr>
<tr class="memdesc:a9d180d67243bc16af61e15bf8f3edaf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a short value from a certain address in the Propeller Chip's dedicated EEPROM. If you are fetching several short values, make sure to add 2 to the addr value with each successive call.  <a href="#a9d180d67243bc16af61e15bf8f3edaf4"></a><br/></td></tr>
<tr class="memitem:aa11b3428dd6ff89dc1421fd5c72f5364"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="html/badgetools_8h.html#aa11b3428dd6ff89dc1421fd5c72f5364">ee_writeInt</a> (int value, int addr)</td></tr>
<tr class="memdesc:aa11b3428dd6ff89dc1421fd5c72f5364"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store an int value at a certain address in the Propeller Chip's dedicated EEPROM. An int value occupies four bytes, so the next value should be stored at an address value that's four bytes higher.  <a href="#aa11b3428dd6ff89dc1421fd5c72f5364"></a><br/></td></tr>
<tr class="memitem:ac9b948eb8159342a8a3e5f036982d21d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="html/badgetools_8h.html#ac9b948eb8159342a8a3e5f036982d21d">ee_readInt</a> (int addr)</td></tr>
<tr class="memdesc:ac9b948eb8159342a8a3e5f036982d21d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an int value from a certain address in the Propeller Chip's dedicated EEPROM. If you are fetching several int values, make sure to add 4 to the addr value with each successive call.  <a href="#ac9b948eb8159342a8a3e5f036982d21d"></a><br/></td></tr>
<tr class="memitem:ae21359eeb100b411446406e27e80f5b5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="html/badgetools_8h.html#ae21359eeb100b411446406e27e80f5b5">ee_writeFloat32</a> (float fpVal, int addr)</td></tr>
<tr class="memdesc:ae21359eeb100b411446406e27e80f5b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store a 32-bit precision floating point value at a certain address in the Propeller Chip's dedicated EEPROM. A 32-bit value occupies four bytes so if you are storing values in a sequence, make sure to add 4 to each addr parameter value.  <a href="#ae21359eeb100b411446406e27e80f5b5"></a><br/></td></tr>
<tr class="memitem:af2f185bea5d8ab9f4fdfeb42eed3200b"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="html/badgetools_8h.html#af2f185bea5d8ab9f4fdfeb42eed3200b">ee_readFloat32</a> (int addr)</td></tr>
<tr class="memdesc:af2f185bea5d8ab9f4fdfeb42eed3200b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch a 32-bit precision floating point value from a certain address in the Propeller Chip's dedicated EEPROM. A 32-bit value occupies four bytes so if you are fetching values in a sequence, make sure to add 4 to each addr parameter value.  <a href="#af2f185bea5d8ab9f4fdfeb42eed3200b"></a><br/></td></tr>
<tr class="memitem:a09637325db750de4f3d83dc00fe8bd4b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="html/badgetools_8h.html#a09637325db750de4f3d83dc00fe8bd4b">ee_writeStr</a> (char *s, int n, int addr)</td></tr>
<tr class="memdesc:a09637325db750de4f3d83dc00fe8bd4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store a string of byte values starting at a certain address in the Propeller Chip's dedicated EEPROM.  <a href="#a09637325db750de4f3d83dc00fe8bd4b"></a><br/></td></tr>
<tr class="memitem:a8b27b14b34b9f6ff9fc941c99f382f58"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="html/badgetools_8h.html#a8b27b14b34b9f6ff9fc941c99f382f58">ee_readStr</a> (unsigned char *s, int n, int addr)</td></tr>
<tr class="memdesc:a8b27b14b34b9f6ff9fc941c99f382f58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch a string of byte values starting at a certain address in Propeller Chip's dedicated EEPROM.  <a href="#a8b27b14b34b9f6ff9fc941c99f382f58"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Infrared Communication</div></td></tr>
<tr class="memitem:a70d4165aad7ecba5f7fd236acfda7a8b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="html/badgetools_8h.html#a70d4165aad7ecba5f7fd236acfda7a8b">send</a> (char *s)</td></tr>
<tr class="memdesc:a70d4165aad7ecba5f7fd236acfda7a8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a character string to another badge. Example: char s[] = "Hello other badge"; send(s);.  <a href="#a70d4165aad7ecba5f7fd236acfda7a8b"></a><br/></td></tr>
<tr class="memitem:ab471860eadefbfa792ad85d9eccf972d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="html/badgetools_8h.html#ab471860eadefbfa792ad85d9eccf972d">receive</a> (char *s)</td></tr>
<tr class="memdesc:ab471860eadefbfa792ad85d9eccf972d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive a character string from another badge.  <a href="#ab471860eadefbfa792ad85d9eccf972d"></a><br/></td></tr>
<tr class="memitem:af520c5172c1a2d5df86c6d63a74ad766"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af520c5172c1a2d5df86c6d63a74ad766"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="html/badgetools_8h.html#af520c5172c1a2d5df86c6d63a74ad766">irclear</a> (void)</td></tr>
<tr class="memdesc:af520c5172c1a2d5df86c6d63a74ad766"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the infrared send/receive buffers. The most common use of this function is to clear any stray messages that my have arrived before receiving a contact from another badge. <br/></td></tr>
<tr class="memitem:a6bf90a9784a8a2dca1ef5c348a1301f6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="html/badgetools_8h.html#a6bf90a9784a8a2dca1ef5c348a1301f6">irprint</a> (const char *fmt,...)</td></tr>
<tr class="memdesc:a6bf90a9784a8a2dca1ef5c348a1301f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use to store transmit strings to another badge in a manner similar to displaying combinations of strings and variables in the SimpleIDE terminal with the print function. Examples: irprint("Hello eBadge"); float f = PI; int n = 4s; char s[] = "PI and answer to universe"; irprint("%1.3f\n%03d\n %30s\n", f, n, s); // Result to other badge: "Hello EEPROM"[0]"3.141"[10]"042"[10]"PI and answer to universe"[10][0]. This information can be conveniently received by the other badge using the irscan function.  <a href="#a6bf90a9784a8a2dca1ef5c348a1301f6"></a><br/></td></tr>
<tr class="memitem:a3684afd3a183fd9ef6ea915191172278"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="html/badgetools_8h.html#a3684afd3a183fd9ef6ea915191172278">irscan</a> (const char *fmt,...)</td></tr>
<tr class="memdesc:a3684afd3a183fd9ef6ea915191172278"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use to receive strings over IR from another badge in a manner similar to retrieving strings that represent combinations of strings and variables from the SimpleIDE terminal with the scan function. Examples: This example will retrieve what the irprint examples transmitted to the other badge: char s1[14]; eescan(1, "%s", s1); float f; int n; char s2[30]; eescan("%f%d%s", f, n, s2); // Result: s1 = "Hello EEPROM", f = 3.141, n = 42, s2 = "PI and 
answer to universe".  <a href="#a3684afd3a183fd9ef6ea915191172278"></a><br/></td></tr>
<tr class="memitem:a96693183fb5d887b5202c60d1820233b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="html/badgetools_8h.html#a96693183fb5d887b5202c60d1820233b">ir_send</a> (char *s, int ssize)</td></tr>
<tr class="memdesc:a96693183fb5d887b5202c60d1820233b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transmits a string with a specified number of characters over IR.  <a href="#a96693183fb5d887b5202c60d1820233b"></a><br/></td></tr>
<tr class="memitem:a1b8fdf911ee16f5946676bc74d225fea"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="html/badgetools_8h.html#a1b8fdf911ee16f5946676bc74d225fea">ir_receive</a> (char *s, int ssize)</td></tr>
<tr class="memdesc:a1b8fdf911ee16f5946676bc74d225fea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive a string with a specified maxiumum number of characters over IR.  <a href="#a1b8fdf911ee16f5946676bc74d225fea"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">oLED Screen Display (Basics)</div></td></tr>
<tr class="memitem:a6028738aed3da0c111a6bd9102f46793"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="html/badgetools_8h.html#a6028738aed3da0c111a6bd9102f46793">oledprint</a> (const char *fmt,...)</td></tr>
<tr class="memdesc:a6028738aed3da0c111a6bd9102f46793"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use to display strings on the oLED display in a manner similar to displaying combinations of strings and variables in the SimpleIDE terminal with the print function. Example: oledprint("Hello!!!"); text_size(SMALL); cursor(0, 4); float f = PI; int n = 4s; char s[] = "PI and Universe"; oledprint("%1.3f, %03d\n%30s", f, n, s); // Result to oLED display: Upper half large print by default - Hello!!! Small print line 4: 1.414, 042 Line 5 "PI and Universe".  <a href="#a6028738aed3da0c111a6bd9102f46793"></a><br/></td></tr>
<tr class="memitem:a091c48ccdba4fcd6b32e0a19dc7f4ec6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="html/badgetools_8h.html#a091c48ccdba4fcd6b32e0a19dc7f4ec6">text_size</a> (int size)</td></tr>
<tr class="memdesc:a091c48ccdba4fcd6b32e0a19dc7f4ec6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the text size to either 32x16 pixel (LARGE) or 7x5 (SMALL) characters. Examples: text_size(LARGE);...text_size(SMALL)...text_size(LARGE).  <a href="#a091c48ccdba4fcd6b32e0a19dc7f4ec6"></a><br/></td></tr>
<tr class="memitem:a733e39ddfa480339e34d9d9db7f4135a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="html/badgetools_8h.html#a733e39ddfa480339e34d9d9db7f4135a">cursor</a> (int col, int row)</td></tr>
<tr class="memdesc:a733e39ddfa480339e34d9d9db7f4135a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Position the cursor to a certain column and row for printing text on the oLED display. Column can be 0 to 7 and row can be 0 or 1 in default LARGE text mode. In SMALL text mode, column can be 0 to 31, and row can be 0 to 7.  <a href="#a733e39ddfa480339e34d9d9db7f4135a"></a><br/></td></tr>
<tr class="memitem:a035708500800248f70da38da2f6fa9cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="html/badgetools_8h.html#a035708500800248f70da38da2f6fa9cb">string</a> (char *str)</td></tr>
<tr class="memdesc:a035708500800248f70da38da2f6fa9cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Display a character string on the oLED display.  <a href="#a035708500800248f70da38da2f6fa9cb"></a><br/></td></tr>
<tr class="memitem:a7eb16f95fef7cb1c5e9cd637965b88d1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="html/badgetools_8h.html#a7eb16f95fef7cb1c5e9cd637965b88d1">clear</a> (void)</td></tr>
<tr class="memdesc:a7eb16f95fef7cb1c5e9cd637965b88d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the display.  <a href="#a7eb16f95fef7cb1c5e9cd637965b88d1"></a><br/></td></tr>
<tr class="memitem:afd4ec7dd4a3589700b1d8835ac8383d1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afd4ec7dd4a3589700b1d8835ac8383d1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="html/badgetools_8h.html#afd4ec7dd4a3589700b1d8835ac8383d1">invert</a> (int i)</td></tr>
<tr class="memdesc:afd4ec7dd4a3589700b1d8835ac8383d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invert (or not) the pixel colors in the display. Use invert(0) for white pixels on a black background, or invert(1) for black pixels on a white background. <br/></td></tr>
<tr class="memitem:a56688ab10bc5a4e222f39c6e5d6a5c67"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="html/badgetools_8h.html#a56688ab10bc5a4e222f39c6e5d6a5c67">point</a> (int x, int y, int color)</td></tr>
<tr class="memdesc:a56688ab10bc5a4e222f39c6e5d6a5c67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Plot a point on the oLED screen.  <a href="#a56688ab10bc5a4e222f39c6e5d6a5c67"></a><br/></td></tr>
<tr class="memitem:a6497d423bc1d90c07c0f728b856b577c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="html/badgetools_8h.html#a6497d423bc1d90c07c0f728b856b577c">line</a> (int x0, int y0, int x1, int y1, int c)</td></tr>
<tr class="memdesc:a6497d423bc1d90c07c0f728b856b577c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Plot a line on the oLED screen.  <a href="#a6497d423bc1d90c07c0f728b856b577c"></a><br/></td></tr>
<tr class="memitem:a87a3b9ffecf36325ff9296bafbe9f1e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="html/badgetools_8h.html#a87a3b9ffecf36325ff9296bafbe9f1e0">box</a> (int x0, int y0, int x1, int y1, int c)</td></tr>
<tr class="memdesc:a87a3b9ffecf36325ff9296bafbe9f1e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Plot a box on the oLED screen.  <a href="#a87a3b9ffecf36325ff9296bafbe9f1e0"></a><br/></td></tr>
<tr class="memitem:a2efbe42e2862a171f51cbdb585a0fed2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="html/badgetools_8h.html#a2efbe42e2862a171f51cbdb585a0fed2">shape</a> (char *img, int bw, int xtl, int ytl, int xpics, int ypics)</td></tr>
<tr class="memdesc:a2efbe42e2862a171f51cbdb585a0fed2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Place a shape defined by a char array of pixels on the oLED display. See 11 Shapes to Display.side for example.  <a href="#a2efbe42e2862a171f51cbdb585a0fed2"></a><br/></td></tr>
<tr class="memitem:af338fa6972c970a28b35a58e4fc06795"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af338fa6972c970a28b35a58e4fc06795"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="html/badgetools_8h.html#af338fa6972c970a28b35a58e4fc06795">rotate180</a> ()</td></tr>
<tr class="memdesc:af338fa6972c970a28b35a58e4fc06795"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotate the screen image 180 degrees. See 05 Display Upside- Down.side for example. <br/></td></tr>
<tr class="memitem:a748ca4e4f931f15a3bc41f0f447c1bd3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="html/badgetools_8h.html#a748ca4e4f931f15a3bc41f0f447c1bd3">screen_auto</a> (int state)</td></tr>
<tr class="memdesc:a748ca4e4f931f15a3bc41f0f447c1bd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cause function calls like oledprint, point, and others to appear immediately after the function is called with screen_auto(1). To make multiple changes before manually updating with a call to screen_update, use screen_auto(0). See 04 Screen Auto ON OFF.side for example.  <a href="#a748ca4e4f931f15a3bc41f0f447c1bd3"></a><br/></td></tr>
<tr class="memitem:ac728ad1ddd9104ea650d99d165c81482"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="html/badgetools_8h.html#ac728ad1ddd9104ea650d99d165c81482">screen_getAuto</a> ()</td></tr>
<tr class="memdesc:ac728ad1ddd9104ea650d99d165c81482"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if function calls like oledprint, point, and others are set to appear (1) immediately after the function is called or (0) if multiple changes are made before manually updating with a call to screen_update.  <a href="#ac728ad1ddd9104ea650d99d165c81482"></a><br/></td></tr>
<tr class="memitem:ab74b08ea884f758b08b40091fb9b0043"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="html/badgetools_8h.html#ab74b08ea884f758b08b40091fb9b0043">screen_update</a> (void)</td></tr>
<tr class="memdesc:ab74b08ea884f758b08b40091fb9b0043"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manually update the screen image after. Typically used after multiple oLED function calls after screen_auto(0). See 04 Screen Auto ON OFF.side for example.  <a href="#ab74b08ea884f758b08b40091fb9b0043"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">oLED Screen Display (Intermediate)</div></td></tr>
<tr class="memitem:a7e1edcd701fd030835df97f154d73a37"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="html/badgetools_8h.html#a7e1edcd701fd030835df97f154d73a37">screen_scrollRight</a> (int scrollStart, int scrollStop)</td></tr>
<tr class="memdesc:a7e1edcd701fd030835df97f154d73a37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cause the screen to scroll to the right with screen_scrollRight(0, 15).  <a href="#a7e1edcd701fd030835df97f154d73a37"></a><br/></td></tr>
<tr class="memitem:a5f72289d67f288f5bcdab663bfcb9f61"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="html/badgetools_8h.html#a5f72289d67f288f5bcdab663bfcb9f61">screen_scrollLeft</a> (int scrollStart, int scrollStop)</td></tr>
<tr class="memdesc:a5f72289d67f288f5bcdab663bfcb9f61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cause the screen to scroll to the left with screen_scrollLeft(0, 15).  <a href="#a5f72289d67f288f5bcdab663bfcb9f61"></a><br/></td></tr>
<tr class="memitem:a0c3564d1ab3c838b26acaad01fd4a23e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="html/badgetools_8h.html#a0c3564d1ab3c838b26acaad01fd4a23e">screen_scrollRightDiag</a> (int scrollStart, int scrollStop)</td></tr>
<tr class="memdesc:a0c3564d1ab3c838b26acaad01fd4a23e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cause the screen to scroll diagonally to the right with screen_scrollRightDiag(0, 15).  <a href="#a0c3564d1ab3c838b26acaad01fd4a23e"></a><br/></td></tr>
<tr class="memitem:addde96d683657b2ed92de7f932adb6b0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="html/badgetools_8h.html#addde96d683657b2ed92de7f932adb6b0">screen_scrollLeftDiag</a> (int scrollStart, int scrollStop)</td></tr>
<tr class="memdesc:addde96d683657b2ed92de7f932adb6b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cause the screen to scroll diagonally to the left with screen_scrollLeftDiag(0, 15).  <a href="#addde96d683657b2ed92de7f932adb6b0"></a><br/></td></tr>
<tr class="memitem:a4c346e03668ffc0b4c572f4ae34663ff"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="html/badgetools_8h.html#a4c346e03668ffc0b4c572f4ae34663ff">screen_scrollStop</a> (void)</td></tr>
<tr class="memdesc:a4c346e03668ffc0b4c572f4ae34663ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop screen scrolling action.  <a href="#a4c346e03668ffc0b4c572f4ae34663ff"></a><br/></td></tr>
<tr class="memitem:a25c29b5d16e8f3d4306bb0f6d4becbb6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="html/badgetools_8h.html#a25c29b5d16e8f3d4306bb0f6d4becbb6">screen_image</a> (char *imgaddr)</td></tr>
<tr class="memdesc:a25c29b5d16e8f3d4306bb0f6d4becbb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Display an image using an array holding an image generated by software that is compatible with the screen's scanning. See 12 Image to Display.side for an example.  <a href="#a25c29b5d16e8f3d4306bb0f6d4becbb6"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Misc</div></td></tr>
<tr class="memitem:a2c7f6975ac403b7b7453711cf08ff736"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="html/badgetools_8h.html#a2c7f6975ac403b7b7453711cf08ff736">dev_ee_show</a> (int byteCount, int address)</td></tr>
<tr class="memdesc:a2c7f6975ac403b7b7453711cf08ff736"><td class="mdescLeft">&#160;</td><td class="mdescRight">Display EEPROM contents as a combination of printable characters and numeric values (when not printable) in square brackets [], See 02 View First and Last 64 Bytes with Terminal.side for example.  <a href="#a2c7f6975ac403b7b7453711cf08ff736"></a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="member-group"></a>
Accelerometer</h2></td></tr>
<tr class="memitem:a7128a4e590a2234a131871c4a9b04632"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7128a4e590a2234a131871c4a9b04632"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="html/badgetools_8h.html#a7128a4e590a2234a131871c4a9b04632">SCR_BLACK</a>&#160;&#160;&#160;(0)</td></tr>
<tr class="memdesc:a7128a4e590a2234a131871c4a9b04632"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets an oLED screen pixel to black. Example: point(27, 35, SCR_BLACK) sets a pixel 27 from the right and 35 down to black. <br/></td></tr>
<tr class="memitem:ae98d55a38e54ddb38901c04ed4311fdf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae98d55a38e54ddb38901c04ed4311fdf"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="html/badgetools_8h.html#ae98d55a38e54ddb38901c04ed4311fdf">SCR_WHITE</a>&#160;&#160;&#160;(1)</td></tr>
<tr class="memdesc:ae98d55a38e54ddb38901c04ed4311fdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets an oLED screen pixel to white. Example: point(100, 50, SCR_WHITE) sets a pixel 100 from the right and 50 down to white. <br/></td></tr>
<tr class="memitem:aa1af51bb4a8e5612208d7035cacf61b4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa1af51bb4a8e5612208d7035cacf61b4"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="html/badgetools_8h.html#aa1af51bb4a8e5612208d7035cacf61b4">SCR_XOR</a>&#160;&#160;&#160;(3)</td></tr>
<tr class="memdesc:aa1af51bb4a8e5612208d7035cacf61b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies XOR operation to pixels in a shape. Example: shape(frog, XOR, 36, 12, 30, 40) would invert the pixels in the frog shape array. the black pixels would be made white and vice-versa. <br/></td></tr>
<tr class="memitem:ac27c2124ca2aed651e06aba3a1468ecb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac27c2124ca2aed651e06aba3a1468ecb"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="html/badgetools_8h.html#ac27c2124ca2aed651e06aba3a1468ecb">LARGE</a>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:ac27c2124ca2aed651e06aba3a1468ecb"><td class="mdescLeft">&#160;</td><td class="mdescRight">For setting oLED character size to 32x16 pixels. Example: text_size(LARGE). <br/></td></tr>
<tr class="memitem:a09c78d2f8feb311dd9fc969a0bf84979"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a09c78d2f8feb311dd9fc969a0bf84979"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="html/badgetools_8h.html#a09c78d2f8feb311dd9fc969a0bf84979">SMALL</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:a09c78d2f8feb311dd9fc969a0bf84979"><td class="mdescLeft">&#160;</td><td class="mdescRight">For setting oLED character size to 7x5 pixels. Example: text_size(SMALL). <br/></td></tr>
<tr class="memitem:a970af8d81d68477d5c3daa3389366587"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a970af8d81d68477d5c3daa3389366587"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="html/badgetools_8h.html#a970af8d81d68477d5c3daa3389366587">AY</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:a970af8d81d68477d5c3daa3389366587"><td class="mdescLeft">&#160;</td><td class="mdescRight">For choosing the accelerometer's y-axis. Example accel(AY) returns the component of the earth's gravitational field acting on the accelerometer's y-axis. <br/></td></tr>
<tr class="memitem:aabc40350f8f80c9c718c44dea61e10fe"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aabc40350f8f80c9c718c44dea61e10fe"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="html/badgetools_8h.html#aabc40350f8f80c9c718c44dea61e10fe">AX</a>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:aabc40350f8f80c9c718c44dea61e10fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">For choosing the accelerometer's x-axis. Example accel(AX) returns the component of the earth's gravitational field acting on the accelerometer's x-axis. <br/></td></tr>
<tr class="memitem:a710ca8e0983dc5ea5c4e1f54ffbee999"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a710ca8e0983dc5ea5c4e1f54ffbee999"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="html/badgetools_8h.html#a710ca8e0983dc5ea5c4e1f54ffbee999">AZ</a>&#160;&#160;&#160;2</td></tr>
<tr class="memdesc:a710ca8e0983dc5ea5c4e1f54ffbee999"><td class="mdescLeft">&#160;</td><td class="mdescRight">For choosing the accelerometer's z-axis. Example accel(AZ) returns the component of the earth's gravitational field acting on the accelerometer's z-axis. <br/></td></tr>
<tr class="memitem:ae2f8547205271aea54d23d0f695a7f55"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="html/badgetools_8h.html#ae2f8547205271aea54d23d0f695a7f55">accel</a> (int axis)</td></tr>
<tr class="memdesc:ae2f8547205271aea54d23d0f695a7f55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Measures acceleration and tilt on one of 3 axes (AX, AY, or AZ) in terms of centigravity (cg) units, which is 100ths of 1 gravity (1 g). With the badge laying flat on a table, the AX is left/right, AY is forward/backward, and AZ is up/down. Example: int x = accel(AX) copies the accelerometer measurement into the x variable. The result will be 0 if held flat, and could go as high as +100 if held on its left edge, or -100 if held on its right edge. Note, the accelerometer's actual resolution is in 64ths of a 1 g.  <a href="#ae2f8547205271aea54d23d0f695a7f55"></a><br/></td></tr>
<tr class="memitem:a5c267ad90290e21681994c5eafabdf4f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="html/badgetools_8h.html#a5c267ad90290e21681994c5eafabdf4f">accels</a> (int *x, int *y, int *z)</td></tr>
<tr class="memdesc:a5c267ad90290e21681994c5eafabdf4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Measures acceleration and tilt on all 3 axes (x, y, and z) in terms of centigravity (cg) units, which is 100ths of 1 gravity (1 g).  <a href="#a5c267ad90290e21681994c5eafabdf4f"></a><br/></td></tr>
<tr class="memitem:a40142b09632d4f3ef439322f18a4565a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="html/badgetools_8h.html#a40142b09632d4f3ef439322f18a4565a">accel_shaken</a> (void)</td></tr>
<tr class="memdesc:a40142b09632d4f3ef439322f18a4565a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if accelerometer was shaken recently, within the last half second.  <a href="#a40142b09632d4f3ef439322f18a4565a"></a><br/></td></tr>
</table>
<a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>This library provides convenient functions for a variety of Parallax eBadge operations. </p>
<dl class="section author"><dt>Author</dt><dd>Parallax Inc.</dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>Copyright (C) Parallax, Inc. 2015. All Rights MIT Licensed.</dd></dl>
<dl class="section version"><dt>Version</dt><dd>0.5</dd></dl>
<p>Note: This is the early adopter version of a library that is fairly new and still a work-in-progress. If you find what you feel are errors or omissions that should be addressed in an upcoming revision, please email <a href="#" onclick="location.href='mai'+'lto:'+'edi'+'to'+'r@p'+'ar'+'all'+'ax'+'.co'+'m'; return false;">edito<span style="display: none;">.nosp@m.</span>r@pa<span style="display: none;">.nosp@m.</span>ralla<span style="display: none;">.nosp@m.</span>x.co<span style="display: none;">.nosp@m.</span>m</a>.</p>
<p>To-do: </p>
<ul>
<li>Shape black to white pixels </li>
<li>Shape white to black pixels </li>
<li>Shape invert pixels </li>
<li>Retest multicore i2c collisions fix </li>
<li>Test with fdserial </li>
<li>Test for global variable name conflicts </li>
<li>Change spin2cpp generated functions that should be void but return 0 </li>
<li>Update retrieve return value </li>
<li>Prune stack sizes </li>
<li>Prune unused functions </li>
<li>Organize private functions in .h file </li>
<li>Fix contact clearing (not same as erasing) </li>
<li>Add ending EEPROM address configuration </li>
<li>Add individual setup options </li>
<li>Add IR TV remote example </li>
<li>Add timekeeping example to package </li>
<li>Add audio example to package </li>
<li>Add dash to x, y, and z axis in docs </li>
<li>Change L &amp; R constants to 1 and 0 </li>
<li>Change ssize to strlen </li>
<li>Add full info to all library files </li>
<li>Replace spin2cpp generated with hand code </li>
</ul>

<p>Definition in file <a class="el" href="html/badgetools_8h_source.html">badgetools.h</a>.</p>
</div><h2>Function Documentation</h2>
<a class="anchor" id="ae2f8547205271aea54d23d0f695a7f55"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int accel </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>axis</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Measures acceleration and tilt on one of 3 axes (AX, AY, or AZ) in terms of centigravity (cg) units, which is 100ths of 1 gravity (1 g). With the badge laying flat on a table, the AX is left/right, AY is forward/backward, and AZ is up/down. Example: int x = accel(AX) copies the accelerometer measurement into the x variable. The result will be 0 if held flat, and could go as high as +100 if held on its left edge, or -100 if held on its right edge. Note, the accelerometer's actual resolution is in 64ths of a 1 g. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">axis</td><td>The AX, AY, or AZ sensing axis. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a40142b09632d4f3ef439322f18a4565a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int accel_shaken </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if accelerometer was shaken recently, within the last half second. </p>
<dl class="section return"><dt>Returns</dt><dd>1 if shaken, 0 if not. </dd></dl>

</div>
</div>
<a class="anchor" id="a5c267ad90290e21681994c5eafabdf4f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void accels </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Measures acceleration and tilt on all 3 axes (x, y, and z) in terms of centigravity (cg) units, which is 100ths of 1 gravity (1 g). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*x</td><td>Address of the variable for storing the x-axis measurement.</td></tr>
    <tr><td class="paramname">*y</td><td>Address of the variable for storing the y-axis measurement.</td></tr>
    <tr><td class="paramname">*z</td><td>Address of the variable for storing the z-axis measurement. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad0292a56ddd0bc4e0cf114599e8eab64"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int badge_setup </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set up all available badge drivers. Call this function at the start of any given program to allow access to ensure that the rest of this library's functions work properly. </p>
<p>A call to this function sets up these badge subsystems: oLED display, LED, RGB LED, touch buttons, accelerometer, infrared communication, and EEPROM storage. Example <a class="el" href="html/badgetools_8h.html#ad0292a56ddd0bc4e0cf114599e8eab64" title="Set up all available badge drivers. Call this function at the start of any given program to allow acc...">badge_setup()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>0. </dd></dl>

</div>
</div>
<a class="anchor" id="a87a3b9ffecf36325ff9296bafbe9f1e0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void box </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Plot a box on the oLED screen. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x0</td><td>The x coordinate of one corner of the box. Measured as a number of pixels from left side of screen. The value increases from 0 (left) to 127 (right).</td></tr>
    <tr><td class="paramname">y0</td><td>The y coordinate of one corner of the box. Measured as a number of pixels from the top of the screen. The value increases from 0 (top) to 63 (bottom).</td></tr>
    <tr><td class="paramname">x1</td><td>The x coordinate of a corner diagonal from the first corner.</td></tr>
    <tr><td class="paramname">y1</td><td>The y coordinate of the corner diagonal from the first corner.</td></tr>
    <tr><td class="paramname">c</td><td>The pixel color 1 for white, 0 for black. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8907df5dd630732bf6f0232a41ac87c3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int button </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pad</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the state of a touch button (1) pressed, (0) not pressed. Numbering {6, 5, 4, 3, 2, 1, 0} maps the pads by {OSH, P17, P16, P15, P25, P26, P27}. Example: int state = button(3); If state stores 1, it means the pad next to the P15 label is pressed. If it instead stores 0, the button is not pressed. </p>
<dl class="section return"><dt>Returns</dt><dd>Binary 1 if pressed; 0 if not pressed. </dd></dl>

</div>
</div>
<a class="anchor" id="a8a9ade72d959d6ceb25fa2135800e755"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int buttons </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the states of all seven touch buttons, and returns them in a value with 1s and 0s that correspond to each touch button. Example: int states = <a class="el" href="html/badgetools_8h.html#a8a9ade72d959d6ceb25fa2135800e755" title="Gets the states of all seven touch buttons, and returns them in a value with 1s and 0s that correspon...">buttons()</a>; If states stores 0b1110010, it means: {OSH-pressed, P17-pressed, P16-pressed, P15-not pressed, P25-not pressed, P26-pressed, P27-not pressed}. </p>
<dl class="section return"><dt>Returns</dt><dd>A 7-bit value with binary 1/0 digits indicating the on/off state of the 7 touch buttons. The rightmost binary digit indicates the state of the upper-right button by the P27 label. The second from the right indicates the state of the button by the P26 label, and so on, up through the 5th from the right, </dd></dl>

</div>
</div>
<a class="anchor" id="a7eb16f95fef7cb1c5e9cd637965b88d1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int clear </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear the display. </p>
<p>Returns cursor to top-left 0, 0. </p>

</div>
</div>
<a class="anchor" id="a0418dc4511db1c97abdda0aa224c829f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int contacts_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find out how many contacts are currently stored in EEPROM. This is useful for setting up a loop to fetch all contacts. </p>
<dl class="section return"><dt>Returns</dt><dd>Number of contacts. </dd></dl>

</div>
</div>
<a class="anchor" id="ae0c1e9fbf92b55e20438d8e21c3d3c28"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void contacts_setStartAddr </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the start address of the contacts. This can be used to reserve some user EEPROM space for other purposes before the start of the contacts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>EEPROM starting address for contact storage. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a733e39ddfa480339e34d9d9db7f4135a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cursor </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>row</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Position the cursor to a certain column and row for printing text on the oLED display. Column can be 0 to 7 and row can be 0 or 1 in default LARGE text mode. In SMALL text mode, column can be 0 to 31, and row can be 0 to 7. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">col</td><td>the column (character position) from left.</td></tr>
    <tr><td class="paramname">row</td><td>the row (line number) from top. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2c7f6975ac403b7b7453711cf08ff736"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dev_ee_show </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>byteCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>address</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Display EEPROM contents as a combination of printable characters and numeric values (when not printable) in square brackets [], See 02 View First and Last 64 Bytes with Terminal.side for example. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">byteCount</td><td>Number of bytes to display.</td></tr>
    <tr><td class="paramname">address</td><td>Starting EEPROM address. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aaea98e6d42cb2de7d6f3c050a18a27fc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char ee_readByte </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a byte value from a certain address in the Propeller Chip's dedicated EEPROM. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>The EEPROM address that with the byte value that should be fetched.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value The byte value stored by the EEPROM at the address specified by the addr parameter. </dd></dl>

</div>
</div>
<a class="anchor" id="af2f185bea5d8ab9f4fdfeb42eed3200b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float ee_readFloat32 </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch a 32-bit precision floating point value from a certain address in the Propeller Chip's dedicated EEPROM. A 32-bit value occupies four bytes so if you are fetching values in a sequence, make sure to add 4 to each addr parameter value. </p>
<p>Make sure that the Math box is checked in the Project Manager. In Simple View, click the Show Project Manager button in SimpleIDE's bottom-left corner. Then click the Linker tab, and check the Math Lib box.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>The EEPROM address with the 32-bit floating point float value that should be fetched.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value The float value stored by the EEPROM at the specified address. </dd></dl>

</div>
</div>
<a class="anchor" id="ac9b948eb8159342a8a3e5f036982d21d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ee_readInt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an int value from a certain address in the Propeller Chip's dedicated EEPROM. If you are fetching several int values, make sure to add 4 to the addr value with each successive call. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>The EEPROM address with the int value that should be fetched.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value The int value stored by the EEPROM at the specified address. </dd></dl>

</div>
</div>
<a class="anchor" id="a9d180d67243bc16af61e15bf8f3edaf4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">short ee_readShort </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a short value from a certain address in the Propeller Chip's dedicated EEPROM. If you are fetching several short values, make sure to add 2 to the addr value with each successive call. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>The EEPROM address with the int value that should be fetched.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value The int value stored by the EEPROM at the specified address. </dd></dl>

</div>
</div>
<a class="anchor" id="a8b27b14b34b9f6ff9fc941c99f382f58"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* ee_readStr </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>addr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch a string of byte values starting at a certain address in Propeller Chip's dedicated EEPROM. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Address of a char array to receive the string of bytes fetched from EEPROM.</td></tr>
    <tr><td class="paramname">n</td><td>The number of bytes to copy from EEPROM to the array.</td></tr>
    <tr><td class="paramname">addr</td><td>The EEPROM address of the first byte in the string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The address of the array that stores the characters that were fetched. </dd></dl>

</div>
</div>
<a class="anchor" id="a1ba3896aea3feb5a6ae8c7fa70092054"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ee_writeByte </td>
          <td>(</td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>addr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Store a byte value at a certain address in the Propeller Chip's dedicated EEPROM. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The byte value to store in EEPROM.</td></tr>
    <tr><td class="paramname">addr</td><td>The EEPROM address where the value is to be stored. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae21359eeb100b411446406e27e80f5b5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ee_writeFloat32 </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>fpVal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>addr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Store a 32-bit precision floating point value at a certain address in the Propeller Chip's dedicated EEPROM. A 32-bit value occupies four bytes so if you are storing values in a sequence, make sure to add 4 to each addr parameter value. </p>
<p>Make sure that the Math box is checked in the Project Manager. In Simple View, click the Show Project Manager button in SimpleIDE's bottom-left corner. Then click the Linker tab, and check the Math Lib box.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fpVal</td><td>The 32-bit floating point float value to store in EEPROM.</td></tr>
    <tr><td class="paramname">addr</td><td>The EEPROM address where the value is to be stored. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa11b3428dd6ff89dc1421fd5c72f5364"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ee_writeInt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>addr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Store an int value at a certain address in the Propeller Chip's dedicated EEPROM. An int value occupies four bytes, so the next value should be stored at an address value that's four bytes higher. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The int value to store in EEPROM.</td></tr>
    <tr><td class="paramname">addr</td><td>The EEPROM address where the value is to be stored. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9858528bce4acd6ced284e4c84de9e0b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ee_writeShort </td>
          <td>(</td>
          <td class="paramtype">short&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>addr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Store a short value at a certain address in the Propeller Chip's dedicated EEPROM. A short value occupies two bytes, so the next value should be stored at an address value that's two bytes higher. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The int value to store in EEPROM.</td></tr>
    <tr><td class="paramname">addr</td><td>The EEPROM address where the value is to be stored. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a09637325db750de4f3d83dc00fe8bd4b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ee_writeStr </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>addr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Store a string of byte values starting at a certain address in the Propeller Chip's dedicated EEPROM. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Address of a char array containing the string of bytes.</td></tr>
    <tr><td class="paramname">n</td><td>The number of bytes to copy from the array.</td></tr>
    <tr><td class="paramname">addr</td><td>The EEPROM address of the first byte in the string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa56c6ce64e97f04b4acde7f69b4aa54b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int eeprint </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use to store strings to EEPROM in a manner similar to displaying combinations of strings and variables in the SimpleIDE terminal with the print function. Examples: eeprint("Hello EEPROM"); float f = PI; int n = 4s; char s[] = "PI and answer to universe"; eeprint("%1.3f\n%03d\n
%30s\n", f, n, s); // Result to EEPROM: "Hello EEPROM"[0]"3.141"[10]"042" [10]"PI and answer to universe"[10][0]. This information can be conveniently retrieved back from EEPROM and placed in variables with the eescan function. </p>
<p>String length can be 128 or less.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*fmt</td><td>a print compatible format string.</td></tr>
    <tr><td class="paramname">...</td><td>a print compatible list of arguments.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Record index number in EEPROM. </dd></dl>

</div>
</div>
<a class="anchor" id="aa22d91d3a160d8b14b40db1864bed8d1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int eeprinted </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Can be called before storing a record with eeprint. Example: if(!eeprinted("Hello EEPROM") eeprint("Hello EEPROM");. </p>
<p>String length can be 128 or less.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*fmt</td><td>a print compatible format string.</td></tr>
    <tr><td class="paramname">...</td><td>a print compatible list of arguments.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if not in EEPROM, or the record number if it is. </dd></dl>

</div>
</div>
<a class="anchor" id="af31cd89d7d934033828b58689e59530b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int eescan </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>recIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use to retrieve strings to EEPROM in a manner similar to retrieving strings that represent combinations of strings and variables from the SimpleIDE terminal with the scan function. Examples: This example will retrieve the what the eeprint examples stored in EEPROM: char s1[14]; eescan(1, "%s", s1); float f; int n; char s2[30]; eescan("%f%d%s", f, n, s2); // Result: s1 = "Hello EEPROM", f = 3.141, n = 42, s2 = "PI and 
answer to universe". </p>
<p>String length can be 128 or less.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">recIdx</td><td>An integer record index value.</td></tr>
    <tr><td class="paramname">*fmt</td><td>a print compatible format string.</td></tr>
    <tr><td class="paramname">...</td><td>a print compatible list of arguments.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of blocks successfully scanned. </dd></dl>

</div>
</div>
<a class="anchor" id="a1b8fdf911ee16f5946676bc74d225fea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ir_receive </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ssize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receive a string with a specified maxiumum number of characters over IR. </p>
<p>ssize can be 128 or less.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*s</td><td>Address of the character array to store the string that was received.</td></tr>
    <tr><td class="paramname">ssize</td><td>Maximmum size of the string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The length of the sting. </dd></dl>

</div>
</div>
<a class="anchor" id="a96693183fb5d887b5202c60d1820233b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ir_send </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ssize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transmits a string with a specified number of characters over IR. </p>
<p>ssize can be 128 or less.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*s</td><td>Address of a string to send.</td></tr>
    <tr><td class="paramname">ssize</td><td>Maximmum size of the string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6bf90a9784a8a2dca1ef5c348a1301f6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int irprint </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use to store transmit strings to another badge in a manner similar to displaying combinations of strings and variables in the SimpleIDE terminal with the print function. Examples: irprint("Hello eBadge"); float f = PI; int n = 4s; char s[] = "PI and answer to universe"; irprint("%1.3f\n%03d\n %30s\n", f, n, s); // Result to other badge: "Hello EEPROM"[0]"3.141"[10]"042"[10]"PI and answer to universe"[10][0]. This information can be conveniently received by the other badge using the irscan function. </p>
<p>String length can be 128 or less.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*fmt</td><td>a print compatible format string.</td></tr>
    <tr><td class="paramname">...</td><td>a print compatible list of arguments.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Record index number in EEPROM. </dd></dl>

</div>
</div>
<a class="anchor" id="a3684afd3a183fd9ef6ea915191172278"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int irscan </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use to receive strings over IR from another badge in a manner similar to retrieving strings that represent combinations of strings and variables from the SimpleIDE terminal with the scan function. Examples: This example will retrieve what the irprint examples transmitted to the other badge: char s1[14]; eescan(1, "%s", s1); float f; int n; char s2[30]; eescan("%f%d%s", f, n, s2); // Result: s1 = "Hello EEPROM", f = 3.141, n = 42, s2 = "PI and 
answer to universe". </p>
<p>Total string length can be 128 or less.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*fmt</td><td>a print compatible format string.</td></tr>
    <tr><td class="paramname">...</td><td>a print compatible list of arguments.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of blocks successfully scanned. </dd></dl>

</div>
</div>
<a class="anchor" id="aab5acb9b826ee20df2bc52d0c9912806"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void led </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a blue LED (from 0 to 5) to a state (ON or OFF). Examples: led(1, ON) turns the blue LED next to the P26 label on. led(3, OFF) turns the blue LED by the P15 label off. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The number of the LED to turn on or off. This number can be in the 0 to 5 range. The numbers {0, 1, 2, 3, 4, 5} control the LEDs by the labels {P27, P26, P25, P15, P16, P17}.</td></tr>
    <tr><td class="paramname">state</td><td>Value that turns the LED on or off. Use ON or 1 to turn the LED on, or OFF or 0 to turn the LED off. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a01e98884f4e84a900658123df508c2b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void leds </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bits</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the on/off states of the 6 blue LEDs with a number that contains six binary 1/0 digits. How does the 6 digit binary number work? Count the number of digits from the right, and that's the led number used in the <a class="el" href="html/badgetools_8h.html#aab5acb9b826ee20df2bc52d0c9912806" title="Set a blue LED (from 0 to 5) to a state (ON or OFF). Examples: led(1, ON) turns the blue LED next to ...">led(int n, int state)</a> function. For example, leds(0b110010) is equivalent to these six led calls: led(5, ON); led(4, ON); led(3, OFF); led(2, OFF); led(1, ON); led(0, OFF). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bits</td><td>The value with six binary digits that controls each light. A 1 in the rightmost digit does the same thing as led(0, ON), and a 0 would be the same as led(0, OFF). A 1 in the second digit from the right would do the same thing as led(1, ON), and so on... </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6497d423bc1d90c07c0f728b856b577c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void line </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Plot a line on the oLED screen. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x0</td><td>The x coordinate of the first point in the line. Measured as a number of pixels from left side of screen. The value increases from 0 (left) to 127 (right).</td></tr>
    <tr><td class="paramname">y0</td><td>The y coordinate of the first point in the line. Measured as a number of pixels from the top of the screen. The value increases from 0 (top) to 63 (bottom).</td></tr>
    <tr><td class="paramname">x1</td><td>The x coordinate of the second point in the line.</td></tr>
    <tr><td class="paramname">y1</td><td>The y coordinate of the second point in the line.</td></tr>
    <tr><td class="paramname">c</td><td>The pixel color 1 for white, 0 for black. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6028738aed3da0c111a6bd9102f46793"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int oledprint </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use to display strings on the oLED display in a manner similar to displaying combinations of strings and variables in the SimpleIDE terminal with the print function. Example: oledprint("Hello!!!"); text_size(SMALL); cursor(0, 4); float f = PI; int n = 4s; char s[] = "PI and Universe"; oledprint("%1.3f, %03d\n%30s", f, n, s); // Result to oLED display: Upper half large print by default - Hello!!! Small print line 4: 1.414, 042 Line 5 "PI and Universe". </p>
<p>String length can be 128 or less. Word wrap is automatic if line width is exceeded.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*fmt</td><td>a print compatible format string.</td></tr>
    <tr><td class="paramname">...</td><td>a print compatible list of arguments.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Record index number in EEPROM. </dd></dl>

</div>
</div>
<a class="anchor" id="a56688ab10bc5a4e222f39c6e5d6a5c67"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void point </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>color</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Plot a point on the oLED screen. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Number of pixels from left side of screen. The value increases from 0 (left) to 127 (right).</td></tr>
    <tr><td class="paramname">y</td><td>the number of pixels from the top of the screen. The value increases from 0 (top)to 63 (bottom). Color is 1 for white, 0 for black.</td></tr>
    <tr><td class="paramname">color</td><td>The pixel color 1 for white, 0 for black. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab471860eadefbfa792ad85d9eccf972d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int receive </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receive a character string from another badge. </p>
<p>String length can be 128 or less.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*s</td><td>Address of the character array to store the string that was received.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The length of the string. </dd></dl>

</div>
</div>
<a class="anchor" id="a65c00fbff5b198cfebecfdae18269cd2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void retrieve </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>contact</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>recIdx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy string with a certain index number from EEPROM to a character array. </p>
<p>String length can be 128 or less.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*contact</td><td>Address of the array where the string should be copied.</td></tr>
    <tr><td class="paramname">recIdx</td><td>Index number of the string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa6eef30729fc643575d5424d6b0826ca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rgb </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>side</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>color</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the color of the left or right RGB LED. Examples: rgb(L, RED) makes the left RGB LED glow red. rgb(R, GREEN) makes the right one glow green. Color options include BLUE, GREEN, CYAN, YELLOW, RED, MAGENTA, WHITE. You can also use OFF to make a light that is glowing turn off. The numeric values of these are listed in Macros -&gt; RGB LEDs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">side</td><td>Which side of the oLED screen (L or R) the RGB LED is on.</td></tr>
    <tr><td class="paramname">color</td><td>RBG LED color setting. Options include BLUE, GREEN, CYAN, YELLOW, RED, MAGENTA, WHITE, and OFF. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a88a29be892374a870d31faf42487629e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rgbs </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>colorL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>colorR</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set both RGB LED colors with one function call. See rgb function for color options. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">colorL</td><td>The color of the left RGB LED.</td></tr>
    <tr><td class="paramname">colorR</td><td>The color of the right RGB LED. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a748ca4e4f931f15a3bc41f0f447c1bd3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void screen_auto </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cause function calls like oledprint, point, and others to appear immediately after the function is called with screen_auto(1). To make multiple changes before manually updating with a call to screen_update, use screen_auto(0). See 04 Screen Auto ON OFF.side for example. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>1 enables auto-update, 0 disables it. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac728ad1ddd9104ea650d99d165c81482"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int screen_getAuto </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if function calls like oledprint, point, and others are set to appear (1) immediately after the function is called or (0) if multiple changes are made before manually updating with a call to screen_update. </p>
<dl class="section return"><dt>Returns</dt><dd>1 if auto-update is enabled, or 0 if it is not. </dd></dl>

</div>
</div>
<a class="anchor" id="a25c29b5d16e8f3d4306bb0f6d4becbb6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void screen_image </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>imgaddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Display an image using an array holding an image generated by software that is compatible with the screen's scanning. See 12 Image to Display.side for an example. </p>
<p>Although scanning starts at the top-left, each pixel in the byte advances downward. After displaying the 8 vertical pixels, it steps to the right a pixel for the next byte. The next byte starts one pixel to the right.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*imgaddr</td><td>Address of the byte array with the 128x64 pixel image to be displayed..</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>. </dd></dl>

</div>
</div>
<a class="anchor" id="a5f72289d67f288f5bcdab663bfcb9f61"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int screen_scrollLeft </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>scrollStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>scrollStop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cause the screen to scroll to the left with screen_scrollLeft(0, 15). </p>
<dl class="section return"><dt>Returns</dt><dd>0 </dd></dl>

</div>
</div>
<a class="anchor" id="addde96d683657b2ed92de7f932adb6b0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int screen_scrollLeftDiag </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>scrollStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>scrollStop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cause the screen to scroll diagonally to the left with screen_scrollLeftDiag(0, 15). </p>
<dl class="section return"><dt>Returns</dt><dd>0 </dd></dl>

</div>
</div>
<a class="anchor" id="a7e1edcd701fd030835df97f154d73a37"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int screen_scrollRight </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>scrollStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>scrollStop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cause the screen to scroll to the right with screen_scrollRight(0, 15). </p>
<dl class="section return"><dt>Returns</dt><dd>0 </dd></dl>

</div>
</div>
<a class="anchor" id="a0c3564d1ab3c838b26acaad01fd4a23e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int screen_scrollRightDiag </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>scrollStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>scrollStop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cause the screen to scroll diagonally to the right with screen_scrollRightDiag(0, 15). </p>
<dl class="section return"><dt>Returns</dt><dd>0 </dd></dl>

</div>
</div>
<a class="anchor" id="a4c346e03668ffc0b4c572f4ae34663ff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int screen_scrollStop </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stop screen scrolling action. </p>
<dl class="section return"><dt>Returns</dt><dd>0 </dd></dl>

</div>
</div>
<a class="anchor" id="ab74b08ea884f758b08b40091fb9b0043"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int screen_update </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Manually update the screen image after. Typically used after multiple oLED function calls after screen_auto(0). See 04 Screen Auto ON OFF.side for example. </p>
<dl class="section return"><dt>Returns</dt><dd>0 </dd></dl>

</div>
</div>
<a class="anchor" id="a70d4165aad7ecba5f7fd236acfda7a8b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int send </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send a character string to another badge. Example: char s[] = "Hello other badge"; send(s);. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*s</td><td>Address of a string to send.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Length of the string that was sent. </dd></dl>

</div>
</div>
<a class="anchor" id="a2efbe42e2862a171f51cbdb585a0fed2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void shape </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bw</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xtl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ytl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xpics</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ypics</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Place a shape defined by a char array of pixels on the oLED display. See 11 Shapes to Display.side for example. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*img</td><td>array's address (its name without the square brackets).</td></tr>
    <tr><td class="paramname">bw</td><td>Can be SCR_WHITE for 1s drawing white pixels, SCR_BLACK for 1s drawing black pixels, or SCR_XOR for inverting.</td></tr>
    <tr><td class="paramname">xtl</td><td>The shape's x top-left coordinate.</td></tr>
    <tr><td class="paramname">ytl</td><td>The shape's y top-left coordinate.</td></tr>
    <tr><td class="paramname">xpics</td><td>The shape's width in pixels.</td></tr>
    <tr><td class="paramname">ypics</td><td>The shape's height in pixels. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a331da7055ac2effe981ac1701d1a6104"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int store </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>contact</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Store a character string of up to 128 characters to EEPROM. Example: char s[] = "abcd"; store(s);. </p>
<p>String length can be 128 or less.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">contact</td><td>Address of the string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Index of the record in EEPROM. The first record gets an index of 0, the second an index of 1, and so-on. </dd></dl>

</div>
</div>
<a class="anchor" id="aae1272cb6eca63cbc542bac82619e374"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int stored </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if a string has already been stored in EEPROM. Example: if(!stored("abcd")) store("abcd");. </p>
<p>*s The address of the string that should be checked against strings stored in EEPROM. String length can be 128 or less.</p>
<dl class="section return"><dt>Returns</dt><dd>1 if a matching record was found, or 0 if not. </dd></dl>

</div>
</div>
<a class="anchor" id="a035708500800248f70da38da2f6fa9cb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void string </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Display a character string on the oLED display. </p>
<p>String length can be 128 or less. Word wrap is automatic if line width is exceeded.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*str</td><td>Address of string to be displayed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a091c48ccdba4fcd6b32e0a19dc7f4ec6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void text_size </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the text size to either 32x16 pixel (LARGE) or 7x5 (SMALL) characters. Examples: text_size(LARGE);...text_size(SMALL)...text_size(LARGE). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>Size of characters, either LARGE (32x16 pixels) or SMALL (7x5 pixels). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Oct 23 2015 17:51:55 for badgetools library by &#160;<a href="html/http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.1.2
</small></address>
</body>
</html>
